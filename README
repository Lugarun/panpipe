# PanPipe #

This software is released into the Public Domain
 -- Chris Warburton <chriswarbo@gmail.com>, 2014-09-28

## Intro ##

PanPipe is a simple Haskell script using PanDoc. It allows code blocks in PanDoc
-compatible documents, eg. Markdown, to be sent to external programs for
processing.

Any code blocks with a "pipe" attribute will have the contents of that attribute
executed as a shell command. The body of the code block will be piped to that
command's stdin, and the stdout will be used as the new content of the code
block. A non-zero exit code will cause PanPipe to exit with that code; stderr
will be sent to PanPipe's stderr.

For example, we can execute shell scripts by piping them to "sh":

```{pipe="sh"}
echo "Hello world"
```

This will cause "sh" to be called, with 'echo "Hello world"' as its stdin.
It will execute the echo command, to produce 'Hello world' as its stdout. This
will become the new contents of the code block, so in the resulting document
this code block will be replaced by:

```
Hello world
```

## Usage Notes ##

### Attributes ###

The "pipe" attribute is removed, but other attributes, classes and IDs remain:

```{#foo .bar baz="quux" pipe="sh"}
echo 'Hello'
```

Will become:

```{#foo .bar baz="quux"}
Hello
```

### Execution Order ###

PanPipe uses two passes: in the first, all code *blocks* are executed, in the
order they appear in the document. Hence later blocks can rely on the effects of
earlier ones. For example:

```{pipe="sh"}
echo "123" > /tmp/blah
echo "hello"
```

```{pipe="sh"}
cat /tmp/blah
```

Will become:

```
hello
```

```
123
```

The second pass executes *inline* code, in the order they appear in the
document.

### Environment ###

Commands will inherit the environment from the shell which calls them, except
they will all be executed in a temporary directory. This makes it easier to
share data between blocks, without leaving cruft behind:

```{pipe="sh"}
echo "hello world" > file1
echo "done"
```

```{pipe="sh"}
cat file1
```

Will become:

```
done
```

```
hello world
```

### Imperative Blocks ###

If you want to execute a block for some effect, but ignore its output, you can
hide the result using a class or attribute:

```{.hidden pipe="python -"}
import random
with open('entropy', 'w') as f:
    f.write(str(random.randint(0, 100)))
```

When rendered to HTML will produce:

<pre class="hidden"><code></code></pre>

### Program Listings ###

A common use-case is to include a program listing in a document *and* show the
results of executing it. You can do this by passing the source code to the Unix
"tee" command, then using a subsequent shell script to run it:

```{.python pipe="tee script1.py"}
print "Foo bar baz"
```

```{pipe="sh"}
python script1.py
```

Will become:

```{.python}
print "Foo bar baz"
```

```
Foo bar baz
```

### Changing Block Order ###

Blocks will always be executed in document-order, so you must arrange dependent
blocks appropriately. However, execution order doesn't have to dictate the order
they're rendered in.

For example, to show the output of a program *before* its source code listing,
we can define the program first, using "tee" to save it to a file and HTML
comments to hide the program listing in the resulting document:

Program listing, commented-out.

```{pipe="tee script2.py"}
print "Hello world"
```

Next we can include a block which executes the file we created:

```{pipe="sh"}
python script2.py
```

Finally we can include a program listing by having a block dump the contents of
the file (using ".python" for syntax highlighting):

```{.python pipe="sh"}
cat script2.py
```

### Inline Snippets ###

PanPipe also works on inline code snippets; for example, my root filesystem is
currently at `df -h | grep "/$" | grep -o "[0-9]*%"`{pipe="sh"} capacity.
